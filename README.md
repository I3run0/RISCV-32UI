# Project Structure

The project is organized into several directories and root-level files:

* **`/` (Root Directory):**
  * `.v` files: Contains the core Verilog modules defining the processor's datapath, control logic, and main components (e.g., `core.v`, `datapath.v`, `control.v`, `alu.v`, `register_file.v`, `main_fsm.v`, `memory.v`).
  * `makefile`: Automates the compilation, simulation, and testing process.
  * `tb.v`: The main integration testbench used for running assembly programs and checking memory output.
  * `tb_regdump.v`: A specialized testbench designed to run assembly programs and dump the state of the register file upon writes, used for verifying internal processor state.

* **`include/`:**
  * `def_select.v`: Contains `define` directives for constants used throughout the design, such as ALU operation codes, instruction opcodes, and immediate type selectors. This promotes readability and maintainability.

* **`test/`:**
  * `teste*.mem`: Hex files containing RISC-V machine code for integration tests run by `tb.v`.
  * `saida*.out`: Actual output generated by running the corresponding `.mem` file with `tb.v`.
  * `saida*.ok`: Expected output files for comparison against `.out` files during testing.
  * `teste*.s`: Some assembly source files corresponding to the `.mem` files, useful for understanding the tests.

* **`reg_tests/`:**
  * `reg_teste*.mem`: Hex files containing machine code specifically designed for testing register file behavior, run by `tb_regdump.v`.
  * `reg_teste*.regok`: Expected register dump output files for comparison against the actual output generated by `tb_regdump.v`.

* **`test_bench/`:**
  * `*_tb.v`: Individual unit testbenches for verifying the functionality of specific modules (like `alu_tb.v`, `register_file_tb.v`, `main_fsm_tb.v`) in isolation.

* **`build/`, `waves/`, `logs/` (Generated by Makefile):**
  * `build/`: Stores compiled simulation executables (`.out`).
  * `waves/`: Stores waveform dump files (`.vcd`) generated during simulation for debugging.
  * `logs/`: Stores log files from test runs, including pass/fail status and diff outputs.

## Architectural Approach (Multi-Cycle)

The processor follows a classic multi-cycle architecture divided into a **Datapath** and a **Control Unit**.

1. **Datapath (`datapath.v`):**
    * Contains the functional units required to execute instructions: Program Counter (PC), Instruction Register (IR), Register File, ALU, Immediate Extender, Muxes, and intermediate registers/latches.
    * Key intermediate registers (`old_pc`, `instruc_reg`, `fread_data1`, `fread_data2`, `alu_out`, `data_to_save`) hold values between clock cycles, allowing data to propagate through the datapath stages over multiple cycles.
    * Muxes (`address_mux`, `alu_src_a_mux`, `alu_src_b_mux`, `result_mux`) select the appropriate data sources for functional units based on control signals for the current cycle and state.
    * Includes specialized handlers (`load_handler.v`, `store_handler.v`) to manage the complexities of byte/half-word memory accesses required by RISC-V.

2. **Control Unit (`control.v`):**
    * Generates the control signals that orchestrate the datapath operations in each clock cycle.
    * Its core is the **Finite State Machine (FSM)** (`main_fsm.v`).
    * **FSM (`main_fsm.v`):**
        * Defines the states an instruction passes through (e.g., `FETCH`, `DECODE`, `EXECUTE_R`, `MEM_ADDR`, `MEM_READ`, `MEM_WRITE`, `MEM_WB`, `ALU_WB`, `BRANCH`, `JAL`, `JALR`).
        * Transitions between states based on the current state and the instruction's opcode (and sometimes funct3/funct7 or ALU flags like `zero`).
        * Outputs control signals (like `PCWrite`, `MemWrite`, `RegWrite`, `ALUSrcA`, `ALUSrcB`, `ResultSrc`, `AdrSrc`, `IRWrite`, `alu_op`) specific to the current state, dictating datapath actions for that cycle.
    * **Decoders (`alu_decoder.v`, `imm_decoder.v`):**
        * `imm_decoder`: Determines the type of immediate value based on the opcode, controlling the `imm_extend` unit.
        * `alu_decoder`: Determines the specific ALU operation based on the `alu_op` signal from the FSM, the instruction's opcode, funct3, and funct7 fields.

## Key Module Descriptions

* **`core.v`:** The top-level module instantiating and connecting the `datapath` and `control` units. It also handles the interface to the external `memory` module.
* **`datapath.v`:** Implements the hardware components where data is stored and manipulated (registers, ALU, muxes). Connects these based on control signals. Includes latches (`flip_flop_enable`) to hold intermediate values between cycles.
* **`control.v`:** Instantiates the FSM and decoders. Takes instruction fields and status flags (`zero`, branch conditions) as input and generates all control signals for the datapath.
* **`main_fsm.v`:** The state machine defining the multi-cycle instruction flow. Outputs state-dependent control signals.
* **`alu.v`:** Performs arithmetic and logical operations. Outputs the result and status flags (`zero`, `blt`, `bge`, `bltu`, `bgeu`).
* **`register_file.v`:** Models the 32 general-purpose RISC-V registers. Handles reads (combinational) and writes (synchronous on clock edge if enabled), ensuring R0 is always zero.
* **`imm_extend.v`:** Generates the 32-bit sign-extended immediate value based on the instruction format (`I`, `S`, `B`, `U`, `J`) selected by `imm_decoder`.
* **`load_handler.v`:** Processes data read from memory during load operations (LW, LH, LB, LHU, LBU), performing necessary byte/halfword selection and sign/zero extension based on `funct3` and address alignment.
* **`store_handler.v`:** Prepares data for store operations (SW, SH, SB). For SW, it passes the register data through. For SH/SB, it merges the relevant byte/halfword from the register data with the word read from memory (read-modify-write approach) based on `funct3` and address alignment.
* **`memory.v`:** A simple behavioral model of memory, reading or writing 32-bit words based on the address and write enable (`we`) signal. Reads are synchronous, writes are synchronous. It initializes from `memory.mem`.
* **`alu_decoder.v` / `imm_decoder.v`:** Combinational logic blocks that decode instruction fields to generate specific control signals for the ALU and Immediate Extender, respectively.
* **`mux2.v` / `mux3.v`:** Generic 2-input and 3-input multiplexers.
* **`flip_flop_enable.v`:** A basic D flip-flop with an enable signal and asynchronous reset, used for PC, IR, and intermediate datapath registers.

## Testing Strategy

The project employs a multi-layered testing approach:

1. **Unit Tests (`test_bench/`):** Each core module (ALU, Register File, FSM, Decoders, Handlers, etc.) has a dedicated testbench. This verifies the module's logic in isolation, ensuring correctness before integration.
2. **Integration Tests (`test/`):** The `tb.v` testbench simulates the entire `core` connected to `memory`. It loads small assembly programs (`.mem` files) into memory and runs them. Correctness is typically verified by checking the final values written to specific memory locations against expected values (`.ok` files). This tests the interaction between the datapath and control unit.
3. **Register Dump Tests (`reg_tests/`):** The `tb_regdump.v` testbench also runs the full core but focuses on verifying the internal state. It monitors register writes and dumps the register number and the written value to a file (`.regactual`). This is compared against manually created expected dumps (`.regok`) to ensure instructions modify the register file correctly. This is crucial for debugging instruction execution logic.
4. **Makefile:** The `makefile` provides targets (`test_unit`, `test_integration`, `test_reg_dump`, `test`) to automate the compilation and execution of all these tests, reporting pass/fail status based on log file analysis or `diff` comparisons.

This comprehensive testing strategy helps ensure the correctness of individual components and the integrated processor.
